class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] result = new int[2];  
        result[0] = result[1] = -1;   
        if(nums == null || nums.length == 0){            
            return result;
        }
        int start = 0;
        int end = nums.length - 1;
            
        while(start + 1 < end){
            int mid = (start + end) / 2;
            if(nums[mid] == target){
                    //return mid;是不对的，因为要找first position of target，所以要不断往前逼近
                    end = mid;
                }else if(nums[mid] < target){
                    start = mid;
                }else{
                    end = mid;
                }
        }
        //此时只剩下两个可能，start和end或者是edge case只有一个数
        if(nums[start] != nums[end]){
            if(nums[start] == target){
                result[0] = start;
            }
            if(nums[end] == target){
                result[0] = end;
            }
        }else if(nums[start] == nums[end] && start != end){
            if(nums[start] == target){
                result[0] = start;
            }else{return result;}      
        }else{
            if(nums[start] == target){
                result[0] = result[1] = start;
                return result;
            }else{return result;}
        }
        //找到result[0]之后开始找result[1],此时已经不包括edge case了，也就是说起码两个格子以上
        if(result[0] != -1){
            int first = result[0];
            if(first + 1 == nums.length){
                result[1] = first;
                return result;
            }else{
                for(int i = first + 1; i < nums.length; i++){
                    if(nums[i] != nums[i - 1]){
                        result[1] = i - 1;
                        return result;
                    }               
                }
                result[1] = nums.length - 1;
            }
            

        }
        return result;
        
    }
}
