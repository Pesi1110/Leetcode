V1:
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] result = new int[2];  
        result[0] = result[1] = -1;   
        if(nums == null || nums.length == 0){            
            return result;
        }
        int start = 0;
        int end = nums.length - 1;
            
        while(start + 1 < end){
            int mid = (start + end) / 2;
            if(nums[mid] == target){
                    //return mid;是不对的，因为要找first position of target，所以要不断往前逼近
                    end = mid;
                }else if(nums[mid] < target){
                    start = mid;
                }else{
                    end = mid;
                }
        }
        //此时只剩下两个可能，start和end或者是edge case只有一个数
        if(nums[start] != nums[end]){
            if(nums[start] == target){
                result[0] = start;
            }
            if(nums[end] == target){
                result[0] = end;
            }
        }else if(nums[start] == nums[end] && start != end){
            if(nums[start] == target){
                result[0] = start;
            }else{return result;}      
        }else{
            if(nums[start] == target){
                result[0] = result[1] = start;
                return result;
            }else{return result;}
        }
        //找到result[0]之后开始找result[1],此时已经不包括edge case了，也就是说起码两个格子以上
        if(result[0] != -1){
            int first = result[0];
            if(first + 1 == nums.length){
                result[1] = first;
                return result;
            }else{
                for(int i = first + 1; i < nums.length; i++){
                    if(nums[i] != nums[i - 1]){
                        result[1] = i - 1;
                        return result;
                    }               
                }
                result[1] = nums.length - 1;
            }
            

        }
        return result;
        
    }
}

V2:
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] result = new int[2];  
        result[0] = result[1] = -1;   
        if(nums == null || nums.length == 0){            
            return result;
        }
        int start = 0;
        int end = nums.length - 1;
        int start1 = 0;
        int end1 = nums.length - 1;

        //由于binary search是建立在起码3个格子的基础上，所以先考虑2个格子及以下的部分
        if(nums.length <= 2){
            if(nums[start] == target && nums[end] == target){
                result[0] = start;
                result[1] = end;
                return result;
            }else if(nums[start] == target){
                result[0] = result[1] = start;
            }else if(nums[end] == target){
                result[0] = result[1] = end;
            }else{
                return result;
            }
        }
        if(nums.length > 2){
            while(start + 1 < end){
                int mid = (start + end) / 2;
                if(nums[mid] == target){
                    //return mid;是不对的，因为要找first position of target，所以要不断往前逼近
                    end = mid;
                }else if(nums[mid] < target){
                    start = mid;
                }else{
                    end = mid;
                }
            }
            if(nums[start] == target){
                result[0] = start;
            }else if(nums[start] != target && nums[end] == target){
                result[0] = end;
            }else if(nums[start] != target && nums[end] != target){
                return result;
            }
            while(start1 + 1 < end1){
                int mid1 = (start1 + end1) / 2;
                if(nums[mid1] == target){
                    //return mid;是不对的，因为要找first position of target，所以要不断往前逼近
                    //end = mid;
                    start1 = mid1;
                }else if(nums[mid1] < target){
                    start1 = mid1;
                }else{
                    end1 = mid1;
                }
            }
            if(nums[end1] == target){
                result[1] = end1;
            }else if(nums[start1] == target && nums[end1] != target){
                result[1] = start1;
            }else if(nums[start1] != target && nums[end1] != target){
                return result;
            }
            
        }
        return result;          
    }
}   
